---
title: "코틀린의 특징(고차함수, 익명함수, 인라인함수, 클로저, 꼬리회귀, 제네릭)"
date: 2019-08-21 00:34:28 -0400
categories: kotilin
---

## 일급함수

일급함수는 스스로 객체로써 취급되는 함수로 다른 함수를 파라미터로 전달받고 반환할 수 있는 함수를 뜻한다.
```markdown
# 코틀린의 경우
fun print(body: (Int, Int) -> Int) {
 println(body(5, 5))
}

print({a, b -> a})

# 자바의 경우
public final void print(@NotNull Fuction body) {
 Object result = body.invoke(5, 5);
 System.out.println(result);
}

```

코틀린의 경우 위와 같이 자동으로 컨버팅 될 수 있기 때문에 유동적인 방법도 사용가능하다.

```markdown
private fun print(body: (Int, Int) -> Int) {
 println(body(10, 5))
}

fun sum(a: Int, b: Int) = a + b
fun sub(a: Int, b: Int) = a - b

printResult(::sum) //result = 15
printResult(::sub) //result = 5
```

## inline과 noinline

```markdown
# 코틀린의 경우
fun doSomething(body: () -> Unit) {
 body()
}

fun callFunction() {
 doSomeThing{ println("out") }
}
 
 # 자바의 경우
public void doSomethings(Function body) {
 body.invoke();
}
 
public void callFunction() {
 doSomething(new Function() {
  @Override
  public void invoke() {
   System.out.println("out");
  }
 });
}
```
코틀린이나 자바에서 inline 키워드를 쓰지 않는 경우 조합하는 함수가 많아질수록 계속 N개 만큼의 function object가 생성되어 메모리 할당과 가상 호출에 의한 런타임 오버헤드가 발생한다. 이럴 때 사용하게 되는 것이 inline 키워드이다. inline 함수로 정의된 함수는 컴파일 단계에서 호출하는 방식이 아니라 코드 자체가 복사되는 방식이다.

```markdown
inline fun doSomeThing(body: () -> unit) {
 body()
}

fun callFunction() {
 doSomething { println("out") }
```

inline 함수를 사용하면 Function 인스턴스를 만들지 않고 callFunction 내부에 삽입되어 바로 선언된다. inline 함수는 private 키워드를 사용하여 정의할 수 없고 internal을 사용해야한다. 모든 람다함수에 inline을 쓰고싶지 않을 경우 noinline 키워드를 추가한다.

-인라인 함수의 장,단점
 인라인 함수를 쓰면 메모리 할당과 오버헤드에 효과적이고 메서드를 호출하는게 아니라 복사하기 때문에 성능의 향상으로 이어지지만 컴파일시 변환되는 Byte Code의 길이는 더 길어진다.
 
## 클로저
 
 클로저(Closure)는 상위 함수의 영역(outer scope)의 변수를 접근할 수 있는 함수를 말한다. 코틀린은 클로저를 지원하며, 그렇게 때문에 익명함수는 함수 밖에서 정의된 변수에 접근할 수 있다.
 
```markdown
fun add(x: Int): (Int) -> Int {
 return fun(y: Int): Int {
  return x + y
 }
}
 
fun main(args: Array<String>) {
 val func = add(10)
 val result = func(20)

```
위의 코드에서 add 함수는 익명함수를 리턴한다. 익명함수는 전역변수도, 익명함수의 인자도 아닌 외부에서 정의된 변수 x에 접근하지 못해 컴파일 에러가 발생할 것 같지만 코틀린이 클로저를 지원하기 때문에 컴파일 에러가 발생하지 않는다.

```markdown
# forEach 함수는 익명함수를 인자로 받는다. 람다식으로 생성한 익명함수도 클로저 함수이며, outer scope의 변수에 접근할 수 있다.
var sum = 0
ints.filter { it > 0 }.forEach {
 sum = sum + it
}
print(sum)

# 자바로 아래처럼 리스너를 만들면 컴파일 에러 발생
int x = 5;

view.setOnClickListener(new View.OnClickListener() {
 @Override public void onClick(View v) {
  System.out.prinln(x); //x가 final이 아니기 때문에 클로저를 지원하지 않는 자바에서는 컴파일 에러가 발생.
 }
});

# 코틀린은 가능!
 var x = 5
 
 view.setOnClickListener {
  println(x)
 }
```

 
